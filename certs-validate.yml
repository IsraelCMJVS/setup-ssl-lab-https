---
- name: Validaci√≥n TLS de certificados por URL (PIVOTE RHEL9 - ec2-user)
  hosts: all
  gather_facts: true
  become: true

  vars:
    # === INPUT ===
    urls_certificados: []

    dias_alerta: 90
    dias_reenvio_alerta: 10
    modo_sin_smtp: true  # En lab: true. En cliente: false cuando SMTP est√© listo.

    # Persistencia (LAB friendly)
    pivot_state_dir: /home/ec2-user/cert_monitor/state
    pivot_output_dir: /home/ec2-user/cert_monitor/output
    estado_filename: estado_notificacion.json
    csv_filename: inventario_certificados.csv

    # SMTP (se llena cuando el cliente lo entregue)
    smtp_host: ""
    smtp_port: 25
    smtp_use_starttls: false
    smtp_username: ""
    smtp_password: ""
    correo_from: ""
    correo_to: []

    ambiente_nombre: "LAB SSL DEMO"

  tasks:
    - name: Validar variables m√≠nimas
      assert:
        that:
          - urls_certificados is iterable
          - urls_certificados | length > 0
        fail_msg: "Falta urls_certificados (lista de URLs HTTPS)."

    - name: Asegurar paquetes b√°sicos en pivote (RHEL9)
      package:
        name:
          - openssl
          - python3
        state: present

    - name: Crear directorios persistentes (state/output)
      file:
        path: "{{ item }}"
        state: directory
        owner: ec2-user
        group: ec2-user
        mode: "0755"
      loop:
        - "{{ pivot_state_dir }}"
        - "{{ pivot_output_dir }}"

    - name: Definir paths de trabajo
      set_fact:
        estado_path: "{{ pivot_state_dir }}/{{ estado_filename }}"
        csv_path: "{{ pivot_output_dir }}/{{ csv_filename }}"
      changed_when: false

    - name: Cargar estado previo si existe
      slurp:
        src: "{{ estado_path }}"
      register: prev_state_raw
      failed_when: false
      changed_when: false

    - name: Parsear estado previo
      set_fact:
        prev_state: >-
          {{
            (prev_state_raw.content | b64decode | from_json)
            if (prev_state_raw is defined and prev_state_raw.content is defined)
            else {}
          }}
      changed_when: false

    - name: Inicializar estructuras
      set_fact:
        rows: []
        alert_rows: []
      changed_when: false

    # üî• Parte robusta AAP: iterar URLs v√≠a include_tasks
    - name: Procesar URLs (TLS -> principal/intermedio/CA -> expiraci√≥n)
      include_tasks: tasks/procesar_url.yml
      loop: "{{ urls_certificados }}"
      loop_control:
        loop_var: url_item

    - name: Generar inventario CSV
      copy:
        dest: "{{ csv_path }}"
        owner: ec2-user
        group: ec2-user
        mode: "0644"
        content: |
          URL,Cert_Principal,Vigencia_Principal,Dias_Principal,Cert_Intermedio,Vigencia_Intermedio,Dias_Intermedio,Cert_CA,Vigencia_CA,Dias_CA,Estado
          {% for r in rows %}
          {{ r.url }},{{ r.principal_subject | replace(',', ' ') }},{{ r.principal_end | replace(',', ' ') }},{{ r.principal_days }},{{ r.inter_subject | replace(',', ' ') }},{{ r.inter_end | replace(',', ' ') }},{{ r.inter_days }},{{ r.ca_subject | replace(',', ' ') }},{{ r.ca_end | replace(',', ' ') }},{{ r.ca_days }},{{ r.estado }}
          {% endfor %}

    - name: Definir banderas para env√≠o seg√∫n pol√≠tica
      set_fact:
        now_iso: "{{ ansible_date_time.iso8601 }}"
        has_alerts: "{{ (alert_rows | length) > 0 }}"
        last_alert_iso: "{{ prev_state.last_alert_iso | default('') }}"
        last_monthly_iso: "{{ prev_state.last_monthly_iso | default('') }}"
      changed_when: false

    - name: Calcular si toca enviar ALERTA (cada 10 d√≠as)
      set_fact:
        send_alert: >-
          {{
            has_alerts and (
              last_alert_iso == '' or
              ((now_iso | to_datetime) - (last_alert_iso | to_datetime)).days >= dias_reenvio_alerta
            )
          }}
      changed_when: false

    - name: Calcular si toca enviar mensual (sin alertas)
      set_fact:
        send_monthly: >-
          {{
            (not has_alerts) and (
              last_monthly_iso == '' or
              ((now_iso | to_datetime).month != (last_monthly_iso | to_datetime).month) or
              ((now_iso | to_datetime).year != (last_monthly_iso | to_datetime).year)
            )
          }}
      changed_when: false

    - name: Preparar asunto y cuerpo del correo
      set_fact:
        mail_subject: >-
          {{
            ('[ALERTA SSL] ' ~ ambiente_nombre ~ ' - Certificados pr√≥ximos a vencer')
            if has_alerts else
            ('[INFO SSL] ' ~ ambiente_nombre ~ ' - Reporte mensual sin alertas')
          }}
        mail_body: |
          {% if has_alerts %}
          Se detectaron certificados pr√≥ximos a vencer (‚â§ {{ dias_alerta }} d√≠as).

          Resumen:
          - Total URLs evaluadas: {{ rows | length }}
          - URLs en umbral: {{ alert_rows | length }}

          Detalle (solo en umbral):
          {% for r in alert_rows %}
          URL: {{ r.url }}
            - Principal: {{ r.principal_days }} d√≠as | Expira: {{ r.principal_end }}
            - Intermedio: {{ r.inter_days }} d√≠as | Expira: {{ r.inter_end }}
            - CA: {{ r.ca_days }} d√≠as | Expira: {{ r.ca_end }}
          {% endfor %}

          Se adjunta inventario CSV: {{ csv_filename }}.
          Pol√≠tica: mientras existan certificados en umbral, se notificar√° cada {{ dias_reenvio_alerta }} d√≠as.
          {% else %}
          Reporte mensual TLS.
          No se detectaron certificados pr√≥ximos a vencer (‚â§ {{ dias_alerta }} d√≠as).
          Total URLs evaluadas: {{ rows | length }}

          Se adjunta inventario CSV: {{ csv_filename }}.
          {% endif %}
      changed_when: false

    - name: Enviar correo v√≠a SMTP (solo si aplica y no estamos en modo_sin_smtp)
      shell: |
        python3 - << 'PY'
        import os, ssl, smtplib
        from email.message import EmailMessage

        smtp_host = {{ smtp_host | to_json }}
        smtp_port = int({{ smtp_port }})
        use_starttls = bool({{ smtp_use_starttls | to_json }})
        username = {{ smtp_username | to_json }}
        password = {{ smtp_password | to_json }}
        mail_from = {{ correo_from | to_json }}
        mail_to = {{ correo_to | to_json }}
        subject = {{ mail_subject | to_json }}
        body = {{ mail_body | to_json }}
        attach_path = {{ csv_path | to_json }}

        if not smtp_host:
          raise SystemExit("smtp_host vac√≠o. Configure SMTP o active modo_sin_smtp.")

        msg = EmailMessage()
        msg["From"] = mail_from
        msg["To"] = ", ".join(mail_to)
        msg["Subject"] = subject
        msg.set_content(body)

        with open(attach_path, "rb") as f:
          msg.add_attachment(f.read(), maintype="text", subtype="csv", filename=os.path.basename(attach_path))

        with smtplib.SMTP(smtp_host, smtp_port, timeout=30) as s:
          s.ehlo()
          if use_starttls:
            ctx = ssl.create_default_context()
            s.starttls(context=ctx)
            s.ehlo()
          if username and password:
            s.login(username, password)
          s.send_message(msg)

        print("Correo enviado OK")
        PY
      args:
        executable: /bin/bash
      register: mail_result
      changed_when: false
      failed_when: false
      when: (send_alert or send_monthly) and (not modo_sin_smtp)

    - name: Actualizar estado persistente (cuando se env√≠a por pol√≠tica)
      copy:
        dest: "{{ estado_path }}"
        owner: ec2-user
        group: ec2-user
        mode: "0644"
        content: >-
          {{
            {
              "last_alert_iso": (now_iso if send_alert else last_alert_iso),
              "last_monthly_iso": (now_iso if send_monthly else last_monthly_iso)
            } | to_nice_json
          }}
      when: (send_alert or send_monthly)

    - name: Resumen final
      debug:
        msg:
          - "CSV: {{ csv_path }}"
          - "Estado: {{ estado_path }}"
          - "URLs evaluadas: {{ rows | length }}"
          - "URLs en alerta: {{ alert_rows | length }}"
          - "send_alert={{ send_alert }}, send_monthly={{ send_monthly }}"
